
# CH11. ES6 Class

<br>
<br>

## 1. Class 소개

<br>

ES6에서 도입된 Class 문법은 객체지향 프로그래밍에서 클래스와 관련된 개념을 자바스크립트에 도입하여 객체를 생성하고 관리하는 데 사용됩니다. 

기존의 프로토타입 기반의 객체 생성 방식보다 훨씬 직관적이고 구조화된 코드를 작성할 수 있습니다.

<br>

### 1) Class 선언

Class는 템플릿(혹은 청사진)으로서 객체의 초기 상태(프로퍼티)와 동작(메서드)을 정의합니다.  

```
class Person {
    // 생성자
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // 메서드
    greet() {
        return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
    }
}
```

<br>  

### 2) Class 인스턴스 생성

Class를 사용하여 객체(인스턴스)를 생성할 수 있습니다.

  

```
const person1 = new Person('Alice', 30);
console.log(person1.greet()); // Hello, my name is Alice and I am 30 years old.
```

<br>

### 3) 상속

Class는 다른 Class를 상속받을 수 있습니다. 상속을 통해 기존 Class의 프로퍼티와 메서드를 재사용하고 확장할 수 있습니다.

```
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age); // 부모 Class의 생성자 호출
        this.grade = grade;
    }

    study() {
        return `${this.name} is studying in grade ${this.grade}.`;
    }
}

const student1 = new Student('Bob', 18, 12);
console.log(student1.greet()); // Hello, my name is Bob and I am 18 years old.
console.log(student1.study()); // Bob is studying in grade 12.
```

<br>

### 4) Static 메서드

Static 메서드는 Class의 인스턴스를 생성하지 않고도 호출할 수 있는 메서드입니다.

```
class MathUtil {
    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtil.add(2, 3)); // 5
```

<br>

### 5) Getter와 Setter

Getter와 Setter를 사용하여 Class의 프로퍼티에 접근하고 설정할 수 있습니다.

<br>

```
class Rectangle {
    constructor(width, height) {
        this._width = width;
        this._height = height;
    }

    get area() {
        return this._width * this._height;
    }

    set dimensions({ width, height }) {
        this._width = width;
        this._height = height;
    }
}

const rect = new Rectangle(10, 5);
console.log(rect.area); // 50

rect.dimensions = { width: 20, height: 10 };
console.log(rect.area); // 200
```

<br>  

### 주의사항

- Class는 선언적이고 명확한 구조를 제공하여 코드의 가독성을 높이고, 객체 지향 프로그래밍의 장점을 활용할 수 있게 합니다.
- ES6 이전에는 프로토타입을 직접 다루는 방식이었으나, Class 문법을 사용하면서 보다 간편하고 직관적인 객체 생성과 관리가 가능해졌습니다.
- Class는 생성자, 메서드, 상속, static 메서드, getter와 setter 등 다양한 객체 관련 기능을 제공하여 좀 더 모듈화된 코드를 작성할 수 있도록 합니다.

  

Class 문법은 모던 자바스크립트에서 객체 지향 프로그래밍을 구현하는 데 매우 유용하며, 코드의 유지보수성과 재사용성을 높이는 데 큰 기여를 합니다.

<br>
<br>

## 2. 실습 예제

<br>

- HTML

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ES6 - Class 문법</title>
</head>
<body>

  <h1>ES6 - Class 문법</h1>
  <p>클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다. - 위키백과 -</p>

  <script>

    /* Class 문법 :      

      ES6에서는 클래스(class) 문법이 추가되어 객체지향 프로그래밍을 더 쉽고 강력하게 할 수 있게 되었습니다. 클래스를 사용하여 객체를 정의하고 관리할 수 있습니다.

      1) 개념
        - Class : 클래스는 붕어뻥을 찍어내는 틀. 즉, 데이터는 들어있지 않고 템플릿만 정의해 놓고 한번만 선언해 놓은 것이라고 볼수 있습니다.
        클래스는 정의만 해둔 것이라 메모리에 올라가지 않지만, 실제로 데이터를 오브젝트에 넣으면 메모리에 올라가게 됩니다.
        - Object : 틀을 통해 만들어지는 붕어빵들. 즉, 클래스에 실제로 데이터를 넣어놓고 만든 것을 오브젝트라고 할 수 있습니다.

      2) 옵션
        - class 키워드를 사용하여 클래스를 정의합니다.
        - constructor 메서드는 클래스의 생성자입니다. 객체가 생성될 때 호출되며, 인스턴스 변수를 초기화합니다.
        - 클래스 내부에 정의된 메서드들은 모두 해당 클래스의 프로토타입에 바인딩됩니다.

      3) 기본 문법
      class MyClass {
        // 여러 메서드를 정의할 수 있음
        constructor() { ... }
        method1() { ... }
        method2() { ... }
        method3() { ... }
        ...
      }
    */

    // 이전문법 - 생성자 함수를 사용한 방법
    const User = function(name, age){
      this.name = name;
      this.age = age;
      // this.showName = function(){
      //   console.log(this.name + ', ' + this.age);
      // }
    }

    const user1 = new User('철수', 21);
    const user2 = new User('영희', 27);
    console.log(user1);
    console.log(user2);

    //  Prototype을 이용한 상속 방법
    /* 내부적 동작원리 :
      1) 직접 자료가 있으면 자료를 출력
      2) 자료 없을 경우 부모에서 찾아서 있으면 출력
      3) 부모에 자료가 없을 경우 더 상위부모에서 찾아서 있으면 출력
    */
    User.prototype.job = '여행';
    const user3 = new User();
    console.log(user3.job);

    User.prototype.showName = function(){
      console.log(this.name + ', ' + this.age);
    }

    /* Prototype 을 이용시 장점 :    

      예시1)
      const User = function(name, age){
        this.name = name;
        this.age = age;
        this.showName = function(){
          console.log(this.name + this.age);
        }
      }

      예시2)
      const User = function(name, age){
        this.name = name;
        this.age = age;
      }

      User.prototype.showName = function(){
        console.log(this.name + this.age);
      }

      ***************************************

      여기서 주요한 차이점을 살펴보겠습니다:

      1) 메서드 정의 위치:
      예시 1: 메서드(showName())는 생성자 함수 내부에 직접 정의되어 있습니다.
      예시 2: 메서드(showName())는 생성자 함수의 프로토타입에 추가되어 있습니다.

      2) 메모리 사용:
      예시 1: 각 객체마다 showName() 메서드가 새로 생성됩니다. 따라서 메모리 사용량이 증가할 수 있습니다.
      예시 2: 모든 User 객체가 동일한 showName() 메서드를 공유합니다. 따라서 메모리 사용량이 줄어들고, 메서드의 변경 사항이 모든 객체에 즉시 적용됩니다.
      
      3) 프로토타입 체인:
      예시 1: 프로토타입을 사용하지 않고 메서드를 생성자 함수 내부에 정의했기 때문에 프로토타입 체인이 형성되지 않습니다.
      예시 2: 메서드가 생성자 함수의 프로토타입에 추가되었기 때문에 모든 User 객체가 프로토타입 체인을 통해 해당 메서드를 상속받습니다.

      4) 가독성과 유지보수성:
      예시 2의 방법이 일반적으로 가독성이 더 높고 유지보수성이 더 좋습니다. 메서드를 한 곳에 모아두고 사용할 수 있으므로 코드가 더 구조적이고 관리하기 쉽습니다.

    */

    // showName 메서드 호출
    // showName() 메서드는 User 생성자 함수의 프로토타입에 추가되었기 때문에 User 생성자 함수를 상속받는 모든 객체가 이 메서드를 상속받습니다. 이것이 프로토타입 기반의 상속입니다. 따라서 showName() 메서드는 User 생성자 함수의 인스턴스인 모든 객체에서 사용할 수 있습니다.
    user1.showName(); // "철수21" 출력
    user2.showName(); // "영희27" 출력


    // Class : ES6에 추가된 스펙
    class Person1 {
      constructor(name, age){
        this.name = name;
        this.age = age;
      }

      // showName = () => {
      //   console.log(this.name + this.age);
      // }
    }

    const person1 = new Person1('철수', 21);
    const person2 = new Person1('영희', 27);
    console.log(person1);
    console.log(person2);


    // Getter and Setters
    class Person2 {
      constructor(firstName, lastName, age){
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
      }

      // get을 이용해 값을 리턴
      /* 기본 문법 :
        class MyClass {
          constructor(prop) {
            this._prop = prop;
          }

          get prop() {
            return this._prop;
          }

          set prop(value) {
            this._prop = value;
          }       
        }
      */

     // 주의사항 :  
     /* 
      Setter가 처리될 때 메모리에 있는 값을 할당하는 것이 아니라 Setter의 값을 할당하게 되는데, 이 때 Setter에 전달된 value를 반복해서 호출하게 되서 'Call stack'에러가 발생합니다. 해결방법은 변수명에 반드시 Getter와 Setter안에서 사용되는 변수명에 기존 변수명과 다르게 설정해 줘야 하는데, 관습적으로는 기존 변수명에 '_'붙여서 변수명을 다르게 설정하여 사용합니다! 
     
      에러출력예시) Uncaught RangeError: Maximum call stack size exceeded at set age...
     */
      get age(){
        return this._age;
      }

      // set을 이용해 값을 설정
      set age(value){
        // 잘못 사용할 때를 위한 설정을 여기에...
        // if(value<0){
        //   throw Error('age can not be negative')
        // }
        // this.age = value;

        this._age = value < 0 ? 0 : value; 
      }
    }

    const man1 = new Person2('John', 'job', -1);
    console.log(man1.age); // 사람의 나이가 -1이 될 순 없음! 즉, 사용자가 클래스를 잘 못 사용했을 때 방어적으로 만들수 있도록 Getter와 Setter를 사용하는 것입니다.


    // Public & Private : 브라우저 지원에 문제가 있어서 아직 사용은 비추천. 알고만 있을 것
    // class Experiment{
    //   publicFiled = 2;        // 외부에서 접근 가능!
    //   #privateFiled = 0;      // #(해쉬)를 붙이게 되면 프라이빗한 값이라서 클래스 내부에서만 사용가능! 
    // }

    // const experiment = new Experiment();
    // console.log(experiment.publicFiled);      // 2
    // console.log(experiment.privateFiled);     // undefined


    // Class 상속(Inheritance)
    class Shape{
      constructor(width, height, color){
        this.width = width;
        this.height = height;
        this.color = color;
      }

      drew() {
        // console.log(`drawing ${this.color} color of!`);
        console.log(`drawing ${this.color} color!`);
      }

      getArea() {
        console.log(this.width * this.height);
      }
    }

    class Rectangle extends Shape {}
    // class Triangle extends Shape {}
    class Triangle extends Shape {
      drew() {
        // 부모의 값을 그대로 적용받고 싶을 때 : super를 사용
        super.drew();
        console.log('▲');
      }

      // 삼각형 구하기 : width * height / 2   <= 이때 삼각형은 계산식이 달라지므로 오버라이딩을 이용하여 필요한 함수만 재정의 하여 사용한다.
      getArea() {
        console.log(this.width * this.height / 2);
      }
    }

    const rectangle = new Rectangle(20, 20, 'blue');
    rectangle.drew();
    rectangle.getArea();
    
    const triangle = new Triangle(20, 20, 'red');
    triangle.drew();
    triangle.getArea();
    


    // Class 상속유무 체크하기
    console.log(rectangle instanceof Rectangle);  // true
    console.log(triangle instanceof Rectangle);  // false
    console.log(triangle instanceof Triangle);  // true
    console.log(triangle instanceof Shape);  // true
    console.log(triangle instanceof Object);  // true  <= 자바스크립트에서 만든 모든 인스턴스는 다 오브젝트에서 상속받음! 


  </script>
  
</body>
</html>
```