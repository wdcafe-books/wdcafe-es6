
# CH03. ES6 화살표 함수(Arrow Function)

<br>
<br>

## 1. 화살표 함수 소개

<br>

ES6에서 도입된 화살표 함수(arrow function)는 함수를 더 간결하게 정의할 수 있는 방법을 제공합니다. 

기존의 함수 선언 방식보다 간단하고 명확한 구문을 사용하여 함수를 정의할 수 있습니다. 

<br> 

## 2. 실습 예제

<br>

- HTML

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ES6 - 화살표 함수</title>
</head>
<body>

  <h1>화살표 함수(Arrow Function)</h1>

  <!-- 4. 이벤트를 사용한 경우 -->
  <p><button onclick="alert(this.textContent)">테스트 버튼</button></p>

  <p>
    <button id="btn1">Click1</button> 
    <button id="btn2">Click2</button> 
  </p>
  <p id="demo"></p>

  <script>

    /* 함수선언 방식 :
      1. 함수식 선언(선언적 함수)
      function 함수명(매개변수...){
        // 선언 내용
      }
    
      2. 변수식 선언(익명함수)
      var 변수명 = function(매개변수...){
        // 선언 내용
      }

      3. 생성자 함수식
      var 변수명 = new 생성자함수명(매개변수...);

      4. 화살표 함수
      var 변수명 = (매개변수...) => {
        // 선언 내용
      }
    */

    // 1. 함수식 선언(선언적 함수)
    function sam1(a, b){
      return a + b;
    }

    console.log(sam1(1, 2));    // 3
    
    // 2. 변수식 선언(익명함수)
    let sam2 = function(a, b){
      return a - b;
    }

    /*
    1. 익명함수 : 
      - 익명 함수는 재사용 하지 않는, 한번만 사용할 함수를 위한 개념으로, 따로 함수의 이름을 갖지 않는다.      

      function() {
        console.log("hello!");
      }

    2. 사용시 : 
      - 익명 함수를 사용시에는 리터럴(Literal) 방식으로 변수에 담겨 사용합니다. 이때 리터럴(Literal) 방식이란 
        글자 뜻 그대로 "문자 그대로 읽히는 방식"을 의미하며, 일반적으로 변수에 데이터를 넣을 때 사용하는 방식이 리터럴 방식이다.

        // 리터럴 방식
        let a = 10;
        const b = 20;

        // //익명 함수
        const sayHello = function() {
          console.log("hello!");
        }

      3. 호출시 :
        sayHello();     
    */

    console.log(sam2(7, 2));    // 5

    // 3. 생성자 함수식
    let sam3 = new Function('a', 'b', 'return a * b');

    console.log(sam3(2, 3));    // 6

    /* 
      function User(name) {
        this.name = name;
      }

      let user = new User("철수");
      console.log(user.name); 


      1. 예시를 이용해 new User(매개변수...)가 실행되면 무슨 일이 일어나는지 살펴 보도록 하겠습니다.
        function User(name) {
          // this = {};  (빈 객체가 암시적으로 만들어짐)

          // 새로운 프로퍼티를 this에 추가함
          this.name = name;

          // return this;  (this가 암시적으로 반환됨)
        }

      2. 이제 let user = new User("철수")는 아래 코드를 입력한 것과 동일하게 동작합니다.
        let user = {
          name: "보라",
          isAdmin: false
        };

      3. 호출시 : 
        console.log(user.name); 


      // Book의 생성자 함수를 정의
      function Book(name, page, subject) {
        this.name = name;
        this.page = page;
        this.subject = subject;
        this.teach = function(student) {
          // 메소드 정의
          console.log(student + '에게 ' + this.subject + '를 가르칩니다.');
        };
      }

      // 인스턴스 생성
      const js = new Book('js', 967, 'JavaScript');
      console.log(js); // js에 대한 객체를 반환
      js.teach('A'); // "A에게 JavaScript를 가르칩니다."
      console.log(js.constructor); // f Book() ==> 모든 객체는 constructor 속성을 가짐
      console.log(js instanceof Book); // true ==> js 객체가 Book 생성자 함수의 인스턴스 여부 확인
    */
        

    // 4. 즉시 실행 함수 : 선언과 호출이 동시에 실행하는 함수
    (function(a, b){
      console.log(a + b);      
    })(3, 4);     // 7


    // 5. 화살표 함수
    let sam4 = (a, b) => {
      return a / b;
    }

    console.log(sam4(9, 3));    // 3


    // 6. 화살표 함수의 다양한 표현식
    // 1) 표현식이 하나일 경우
    const sam5 = () => console.log('Hello~~');
    sam5();
    
    // 2) 표현식이 여러개일 경우
    const sam6 = () => {
      let a = 10;
      let b = 20;

      console.log(a + b);
    };
    sam6();   // 30
  
    // 3) 매개변수가 없는 경우
    const sam7 = () => console.log('반가워요~~');
    sam7();

    // 4) 매개변수가 하나일 경우
    const sam8 = a => {
      console.log( a * a );
    }    
    sam8(2);  // 4

    // 5) 매개변수가 여러개일 경우
    const sam9 = (a, b) => {
      console.log( a + b );
    }    
    sam9(2, 3);   // 5

    // 6) 매개변수의 기본값 설정의 경우
    const sam10 = (a=1, b=1) => {
      console.log( a + b );
    }    
    sam10(3, 4);   // 7
    sam10();       // 2
    sam10(3);      // 4   <= 하나만 매개변수 입력시 a값만 적용


    /* 화사표 함수 this 바인딩 : 해당 키워드가 속한 객체를 참조
      1. 혼자 써있다면 전역 객체(window)를 의미
      2. 함수에서는 전역 객체를 의미
      3. 메서드 내부에서는 메서드를 소유한 객체를 의미
      4. 이벤트는 이벤트를 받는 객체 의미
    */

    // 1. 혼자 써있다면 전역 객체(Window)를 의미
    let x = this;
    console.log(x);

    // 2. 함수에서는 전역 객체를 의미
    function test(){
      return this;
    }
    console.log(test());

    // 3. 메서드 내부에서는 메서드를 소유한 객체를 의미
    let person =  {
      name: '홍길동',
      age: 23,
      info: function() {
        console.log(this.name + '의 나이는 ' + this.age + '살 입니다.');
      }
    }

    // 4. 이벤트는 이벤트를 받는 객체 의미
    person.info();


    // 5. 결론
    // 1) 일반함수에서의 this는 전역객체인 'Window'객체 입니다.
    // 2) 이벤트 콜백함수에서의 this는 자기 자신인 '이벤트 받는 대상'이였습니다.
    // 3) 화살표 함수에서의 this는 '함수를 소유한 객체'를 의미합니다.

    // 대상 선택
    const demo = document.getElementById('demo');
    const btn1 = document.getElementById('btn1');
    const btn2 = document.getElementById('btn2');

    // this를 출력하는 일반함수
    const samFn1 = function() {
      demo.innerHTML += this + '<br>';
    }

    // 1. 초기실행 :  함수를 소유한게 Window가 되서 전역객체인 Window 객체가 출력
    window.addEventListener('load', samFn1);

    // 2. 버튼1 클릭 : 함수를 소유한게 버튼이므로 되서 '이벤트 받는 대상'인 HTMLButtonElement이 출력
    btn1.addEventListener('click', samFn1);

    // 3. 버튼2 클릭
    // this를 출력하는 화살표 함수 
    /*
      화살표 함수는 자기가 정의된 스코프에 존재하는 this를 가리킵니다. 즉, 자기의 상위 스코프의 this를 참조하는 것입니다.
      따라서 화살표 함수 내부에서 this는 함수를 정의한 위치의 상위 스코프의 this를 그대로 사용합니다.
    */
    const samFn2 = () => {
      //samFn2 함수 내부에서 this는 선언 시점에서의 상위 스코프인 전역 객체인 Window를 가리킵니다.
      demo.innerHTML += this + '<br>';
    }
    
    btn2.addEventListener('click', samFn2);

  </script>  
</body>
</html>
```