
# CH19. ES6 Async Await

<br>
<br>

## 1. Async & Await 소개

<br>

ES6에서 도입된 `async`와 `await`는 비동기 코드를 더욱 간편하고 동기적으로 보이도록 작성할 수 있게 해주는 문법입니다. 

이 두 문법은 Promise를 기반으로 하며, 비동기 코드를 더 읽기 쉽고 관리하기 쉽게 만들어 줍니다.

<br>  

### 1) async 함수

`async` 키워드를 사용하여 정의된 함수는 항상 Promise를 반환합니다. 내부에서 `await` 키워드를 사용하여 다른 비동기 함수를 호출하면, 

해당 함수가 완료될 때까지 기다립니다. `async` 함수는 다음과 같은 형태를 가집니다:

<br>

```
async function myAsyncFunction() {
    // 비동기 작업을 수행하는 코드
    const result = await someAsyncOperation();
    return result;
}
```

<br>  

### 2) await 키워드

`await` 키워드는 `async` 함수 내에서만 사용될 수 있습니다. `await` 뒤에는 Promise를 반환하는 함수나 비동기 작업을 기다리는 표현식을 사용합니다.

`await` 키워드를 사용하면 해당 작업이 완료될 때까지 함수의 실행을 일시 중지하고, 결과 값을 반환합니다.

<br>

```
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}
```

<br>

위의 예제에서 `await fetch('https://api.example.com/data')`는 네트워크 요청이 완료되기를 기다립니다. 

그 후에 `response.json()`을 호출하여 JSON 데이터를 파싱하고, `data` 변수에 할당합니다. `try-catch` 블록을 사용하여 오류 처리를 간단히 할 수 있습니다.

<br>

### 3) async 함수의 반환 값

`async` 함수는 항상 Promise를 반환합니다. `await` 키워드를 사용해 비동기 작업이 완료될 때까지 기다린 후, 그 결과를 반환합니다.

따라서 `async` 함수를 호출할 때는 `.then()` 메서드나 `await` 키워드를 사용하여 반환된 Promise를 처리해야 합니다.

<br>

```
async function fetchData() {
    return 'Data fetched successfully';
}

fetchData().then(result => {
    console.log(result); // "Data fetched successfully"
});
```

<br>

### 주의할 점

1. **async 함수 내에서만 await 사용**: `await`는 `async` 함수 내에서만 사용할 수 있습니다. 일반적인 함수나 전역 코드에서는 사용할 수 없습니다.
2. **성능 고려**: `await` 키워드를 사용하면 해당 작업이 완료될 때까지 함수가 블록됩니다. 따라서 오래 걸리는 작업은 다른 방법으로 처리해야 할 수 있습니다.
3. **오류 처리**: `async` 함수 내에서 발생하는 오류는 `try-catch` 블록을 사용하여 적절히 처리해야 합니다.

<br>

### [ 요약 ]

`async`와 `await`는 ES6에서 도입된 현대적인 비동기 처리 방법입니다. Promise를 기반으로 하며, 코드를 보다 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 

비동기 코드를 동기적으로 작성할 수 있는 능력을 제공하며, JavaScript에서 비동기 작업을 다룰 때 매우 유용한 도구입니다.

<br>
<br>  

## 2. 예시 샘플

<br>

- HTML

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ES6 - async & await</title>
</head>
<body>
  
  <script>

    /* async & await
      async & await는 자바스크립트 비동기 처리 패턴중의 하나입니다.
      Syntatic Sugar(문법적 설탕) 라고도 불리는데, 코드를 더 읽기 쉽게 작성하고 이해할 수 있도록 도와주는 문법적인 표현방식을 말합니다.
    */

    // 유저 정보 가져오기
    function getUser(userId){
      return new Promise((resolve, reject) => {
        setTimeout(() => {   
          try {
            const user = userId === 1 ? {id: userId, name: 'Basic Coding'} : null;
            // callback(user);
            resolve(user);
          } catch {
            reject(error);
          }
        }, 1000);
      });      
    }

    // 유저 게시글 가져오기
    function getPosts(userId){      
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          const posts = [
            {id: 1, title: 'Post 1'},
            {id: 2, title: 'Post 2'}
          ] 
          resolve(posts);
        });
      })
    }

    // 유저 게시글의 댓글 가져오기
    function getComments(postId){
      return new Promise((resolve, reject) => {
        setTimeout(() => {   
          const comments = [
            {id: 1, text: 'comment 1'},
            {id: 2, text: 'comment 2'},
            {id: 3, text: 'comment 2'},
          ]
          resolve(comments);
        }, 1000);
      })
    }

    function runPromise(){
      getUser(1)  // 0 을 넣으면 에러가 발생! 
        .then(user => {
          if(user){
            console.log('user : ', user);
          }else{
            console.log('유저가 없어요!');
          }
        })
        .catch(err => console.log('err : ', err));
    }

    // runPromise();

    // async & await 적용시 : 코드를 더 쉽게 읽을 수 있습니다.
    // async는 비동기 작업을 처리할 함수를 정의할 때 사용
    // async function runAsyncAwait(){
    //   const user = await getUser(1);      // await는 async 함수 내부에서 비동기 작업의 결과를 기다리는 역할을 합니다.

    //   if(user){
    //     console.log('user : ', user);
    //   }else{
    //     console.log('유저가 없어요!');
    //   }
    // }

    // 에러 출력 표시까지 할 경우 :  try ~ catch 를 사용하면 됩니다! 
    // async function runAsyncAwait(){
    //   try {
    //     const user = await getUser(1); 

    //     if(user){
    //       console.log('user : ', user);
    //     }else{
    //       console.log('유저가 없어요!');
    //     }
    //   } catch (err) {
    //     console.log('err : ', err);
    //   }
    // }

    async function runAsyncAwait(){
      try {
        const user = await getUser(1);
        const posts = await getPosts(user.Id);
        const comments = await getComments(posts[0].Id);

        console.log('user : ', user);
        console.log('posts : ', posts);
        console.log('comments : ', comments);
        return user;
      } catch (err) {
        console.log('err : ', err);
      }
    }

    console.log('Start!');
    // runAsyncAwait();  // <= 이 함수역시 비동기로 동작합니다. 
    // console.log(runAsyncAwait());  // <= Promise 객체를 반환합니다.
    runAsyncAwait().then(user => console.log('user : ', user));
    console.log('End!');

  </script>

</body>
</html>
```